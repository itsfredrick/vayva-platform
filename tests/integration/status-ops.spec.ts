
import { test, expect } from '@playwright/test';
import { UptimeService } from '../../apps/merchant-admin/src/lib/ops/uptimeService';
import { prisma } from '@vayva/db';

test.describe('Status Ops & Uptime', () => {

    test('Uptime Check & Incident Automation', async () => {
        // 1. Setup Check
        const check = await prisma.uptimeCheck.create({
            data: {
                name: 'Test Service A',
                url: 'http://should-fail.com/fail', // Simulates failure in our mock service
                enabled: true
            }
        });

        // 2. First Run (Failure 1) - Should NOT create incident yet
        await UptimeService.runChecks();

        let incidents = await prisma.statusIncident.findMany({ include: { links: true } });
        let related = incidents.filter(i => i.links.some(l => l.uptimeCheckId === check.id));
        expect(related.length).toBe(0);

        // 3. Second Run (Failure 2) - Should Create Incident
        await UptimeService.runChecks();

        incidents = await prisma.statusIncident.findMany({ include: { links: true } });
        related = incidents.filter(i => i.links.some(l => l.uptimeCheckId === check.id));
        expect(related.length).toBe(1);
        expect(related[0].autoGenerated).toBe(true);
        expect(related[0].status).toBe('investigating');

        // 4. Third Run (Failure 3) - Should Idempotently Ignore (No new incident)
        await UptimeService.runChecks();

        const countAfter = await prisma.statusIncident.count({
            where: { links: { some: { uptimeCheckId: check.id } } }
        });
        expect(countAfter).toBe(1);
    });

});
